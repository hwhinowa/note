<div class="con_top">
    <p>Algorithm</p>
    <p class='con_title'>Algorithm practice</p>
</div>
<div class="con">
<article>
    <p class="art_title">달팽이는 올라가고 싶다 (백준, 2869번, 수학)</p>
    <p class="art_sub_title">문제</p>
    <p>
        땅 위에 달팽이가 있다. 이 달팽이는 높이가 V미터인 나무 막대를 올라갈 것이다. <br>
        달팽이는 낮에 A미터 올라갈 수 있다. 하지만, 밤에 잠을 자는 동안 B미터 미끄러진다. 또, 정상에 올라간 후에는 미끄러지지 않는다.<br>
        달팽이가 나무 막대를 모두 올라가려면, 며칠이 걸리는지 구하는 프로그램을 작성하시오.
    </p>
    <p class="art_sub_title">입력</p>
    <p>첫째 줄에 세 정수 A, B, V가 공백으로 구분되어서 주어진다. (1 ≤ B < A ≤ V ≤ 1,000,000,000)</p>
    <p class="art_sub_title">출력</p>
    <p>첫째 줄에 달팽이가 나무 막대를 모두 올라가는데 며칠이 걸리는지 출력한다.<br><br></p>

    <code>
        <span class='variable'>const</span> fs = require('fs');
        <span class='variable'>const</span> input = fs.readFileSync("/dev/stdin").toString().trim().split(" ");

        getTop(input)

        function getTop(arr){
            let up = arr[0];
            let down = arr[1];
            let top = arr[2];

            console.log(Math.ceil((top - up) / (up - down)) + 1)
        }
    </code>
</article>

<article>
    <p class="art_title">ATM (백준, 11399번, 그리디알고리즘/정렬)</p>
    <p class="art_sub_title">문제</p>
    <p>
        인하은행에는 ATM이 1대밖에 없다. 지금 이 ATM앞에 N명의 사람들이 줄을 서있다. 사람은 1번부터 N번까지 번호가 매겨져 있으며, i번 사람이 돈을 인출하는데 걸리는 시간은 Pi분이다.<br>
        사람들이 줄을 서는 순서에 따라서, 돈을 인출하는데 필요한 시간의 합이 달라지게 된다. 예를 들어, 총 5명이 있고, P1 = 3, P2 = 1, P3 = 4, P4 = 3, P5 = 2 인 경우를 생각해보자. [1, 2, 3, 4, 5] 순서로 줄을 선다면, 1번 사람은 3분만에 돈을 뽑을 수 있다. 2번 사람은 1번 사람이 돈을 뽑을 때 까지 기다려야 하기 때문에, 3+1 = 4분이 걸리게 된다. 3번 사람은 1번, 2번 사람이 돈을 뽑을 때까지 기다려야 하기 때문에, 총 3+1+4 = 8분이 필요하게 된다. 4번 사람은 3+1+4+3 = 11분, 5번 사람은 3+1+4+3+2 = 13분이 걸리게 된다. 이 경우에 각 사람이 돈을 인출하는데 필요한 시간의 합은 3+4+8+11+13 = 39분이 된다.<br>
        줄을 [2, 5, 1, 4, 3] 순서로 줄을 서면, 2번 사람은 1분만에, 5번 사람은 1+2 = 3분, 1번 사람은 1+2+3 = 6분, 4번 사람은 1+2+3+3 = 9분, 3번 사람은 1+2+3+3+4 = 13분이 걸리게 된다. 각 사람이 돈을 인출하는데 필요한 시간의 합은 1+3+6+9+13 = 32분이다. 이 방법보다 더 필요한 시간의 합을 최소로 만들 수는 없다.<br>
        줄을 서 있는 사람의 수 N과 각 사람이 돈을 인출하는데 걸리는 시간 Pi가 주어졌을 때, 각 사람이 돈을 인출하는데 필요한 시간의 합의 최솟값을 구하는 프로그램을 작성하시오.
    </p>
    <p class="art_sub_title">입력</p>
    <p>첫째 줄에 사람의 수 N(1 ≤ N ≤ 1,000)이 주어진다. 둘째 줄에는 각 사람이 돈을 인출하는데 걸리는 시간 Pi가 주어진다. (1 ≤ Pi ≤ 1,000)</p>
    <p class="art_sub_title">출력</p>
    <p>첫째 줄에 각 사람이 돈을 인출하는데 필요한 시간의 합의 최솟값을 출력한다.<br><br></p>

    <code>
        <span class='variable'>const</span> input = require('fs').readFileSync('/dev/stdin').toString().trim().split(/\s+/);
        <span class='variable'>const</span> [n,...arr] = input; 

        getMinTime(n, arr);

        function getMinTime(amount, timeArr){
            <span class='variable'>let</span> times = timeArr.sort((a, b) => b - a);
            <span class='variable'>let</span> total = 0;
            
            amount *= 1;

            for(<span class='variable'>let</span> i = 0; i < amount; i++){
                times[i] *= 1;
                
                for(<span class='variable'>let</span> j = 0; j < i + 1; j++){
                    total += times[i];
                }
            }

            console.log(total);
        }
    </code>
</article>

<article>
    <p class="art_title check">계단 오르기 (백준, 2579번, 다이나믹프로그래밍)</p>
    <p class="art_sub_title">문제</p>
    <p>계단 오르기 게임은 계단 아래 시작점부터 계단 꼭대기에 위치한 도착점까지 가는 게임이다. &lt;그림 1&gt;과 같이 각각의 계단에는 일정한 점수가 쓰여 있는데 계단을 밟으면 그 계단에 쓰여 있는 점수를 얻게 된다.</p>
    <img src="/images/algorithm/2-1.png" alt="image">
    <p>
        예를 들어 &lt;그림 2&gt;와 같이 시작점에서부터 첫 번째, 두 번째, 네 번째, 여섯 번째 계단을 밟아 도착점에 도달하면 총 점수는 10 + 20 + 25 + 20 = 75점이 된다.<br>
        계단 오르는 데는 다음과 같은 규칙이 있다.<br>
        1. 계단은 한 번에 한 계단씩 또는 두 계단씩 오를 수 있다. 즉, 한 계단을 밟으면서 이어서 다음 계단이나, 다음 다음 계단으로 오를 수 있다.<br>
        2. 연속된 세 개의 계단을 모두 밟아서는 안 된다. 단, 시작점은 계단에 포함되지 않는다.<br>
        3. 마지막 도착 계단은 반드시 밟아야 한다.<br><br>
        따라서 첫 번째 계단을 밟고 이어 두 번째 계단이나, 세 번째 계단으로 오를 수 있다. 하지만, 첫 번째 계단을 밟고 이어 네 번째 계단으로 올라가거나, 첫 번째, 두 번째, 세 번째 계단을 연속해서 모두 밟을 수는 없다. <br>
        각 계단에 쓰여 있는 점수가 주어질 때 이 게임에서 얻을 수 있는 총 점수의 최댓값을 구하는 프로그램을 작성하시오.
    </p>
    <img src="/images/algorithm/2-2.png" alt="image">
    <p class="art_sub_title">입력</p>
    <p>
        입력의 첫째 줄에 계단의 개수가 주어진다.<br>
        둘째 줄부터 한 줄에 하나씩 제일 아래에 놓인 계단부터 순서대로 각 계단에 쓰여 있는 점수가 주어진다. 계단의 개수는 300이하의 자연수이고, 계단에 쓰여 있는 점수는 10,000이하의 자연수이다.
    </p>
    <p class="art_sub_title">출력</p>
    <p>첫째 줄에 계단 오르기 게임에서 얻을 수 있는 총 점수의 최댓값을 출력한다.</p>

    <code>
        <span class='variable'>let</span> input = require('fs').readFileSync('/dev/stdin').toString().trim().split(/\s+/);
        <span class='variable'>let</span> [n,...arr] = input;

        n *= 1;

        getMaxScore(n, arr);

        function getMaxScore(amount, scores){
            <span class='variable'>let</span> status = 1;
            <span class='variable'>let</span> scoreArr = scores;
            <span class='variable'>let</span> total = 0;
            <span class='variable'>let</span> prevFlag = false;
            
            <span class='comment'>// 점수 배열 숫자로</span>
            for(<span class='variable'>let</span> i = 0; i < scoreArr.length; i++){
                <span class='variable'>let</span> temp = scoreArr[i];
                temp *= 1;
                scoreArr[i] = temp;
            }
            
            total = scoreArr[0];

            for(<span class='variable'>let</span> i = 1; i < amount; i++){
                if(i >= status){
                    <span class='comment'>// 직전 계단을 밟지 않은 상태이면</span>
                    if(!prevFlag){
                        <span class='comment'>// 다음 계단 점수가 다다음 계단보다 크면</span>
                        if(scoreArr[i] > scoreArr[i + 1]){
                            total += scoreArr[i];
                            status += 1;
                            prevFlag = true;
                        }else{
                            total += scoreArr[i + 1];
                            status += 2;
                        }
                        <span class='comment'>// 직전 계단 밟았음</span>
                    }else{
                        total += scoreArr[i + 1];
                        status += 2;
                        prevFlag = false;
                    }
                }
            }
            console.log(total);
        }

    </code>
</article>

<article>
    <p class="art_title check">검문 (백준, 2981번, 수학/정수론/유클리드호제법)</p>
    <p class="art_sub_title">문제</p>
    <p>
        트럭을 타고 이동하던 상근이는 경찰의 검문을 받게 되었다. 경찰은 상근이가 운반하던 화물을 하나하나 모두 확인할 것이기 때문에, 검문하는데 엄청나게 오랜 시간이 걸린다.<br>
        상근이는 시간을 때우기 위해서 수학 게임을 하기로 했다.<br>
        먼저 근처에 보이는 숫자 N개를 종이에 적는다. 그 다음, 종이에 적은 수를 M으로 나누었을 때, 나머지가 모두 같게 되는 M을 모두 찾으려고 한다. M은 1보다 커야 한다.<br>
        N개의 수가 주어졌을 때, 가능한 M을 모두 찾는 프로그램을 작성하시오.
    </p>
    <p class="art_sub_title">입력</p>
    <p>
        첫째 줄에 종이에 적은 수의 개수 N이 주어진다. (2 ≤ N ≤ 100)<br>
        다음 줄부터 N개 줄에는 종이에 적은 수가 하나씩 주어진다. 이 수는 모두 1보다 크거나 같고, 1,000,000,000보다 작거나 같은 자연수이다. 같은 수가 두 번 이상 주어지지 않는다.<br>
        항상 M이 하나 이상 존재하는 경우만 입력으로 주어진다.
    </p>
    <p class="art_sub_title">출력</p>
    <p>첫째 줄에 가능한 M을 공백으로 구분하여 모두 출력한다. 이때, M은 증가하는 순서이어야 한다.<br><br></p>

    <code>
        <span class='variable'>let</span> fs = require('fs');<br>
        <span class='variable'>let</span> [n, ...arr] = fs.readFileSync("/dev/stdin").toString().trim().split(/\s+/);

        n *= 1;

        sameRemainder(n, arr);

        function sameRemainder(amount, numbers){
            <span class='variable'>let</span> numberArr = numbers;
            <span class='variable'>let</span> minNum = Math.min.apply(null, numbers); // 배열 내 최소값
            <span class='variable'>let</span> result = [];

            for(<span class='variable'>let</span> i = 2; i < minNum; i++){
                <span class='variable'>let</span> temp = 0;
                <span class='variable'>let</span> sameFlag = true;

                numberArr.forEach((idx, number) => {
                    if(idx === 0){
                        temp = number % i;
                    }else if(number % i !== temp){
                        sameFlag = false;
                    }

                    if(sameFlag) result.push(i);
                });
            }

            console.log(result);

        }
    </code>
</article>

<article>
    <p class="art_title">최대공약수와 최소공배수 (백준, 2609번, 수학/정수론/유클리드호제법)</p>
    <p class="art_sub_title">문제</p>
    <p>두 개의 자연수를 입력받아 최대 공약수와 최소 공배수를 출력하는 프로그램을 작성하시오.</p>
    <p class="art_sub_title">입력</p>
    <p>첫째 줄에는 두 개의 자연수가 주어진다. 이 둘은 10,000이하의 자연수이며 사이에 한 칸의 공백이 주어진다.</p>
    <p class="art_sub_title">출력</p>
    <p>첫째 줄에는 입력으로 주어진 두 수의 최대공약수를, 둘째 줄에는 입력으로 주어진 두 수의 최소 공배수를 출력한다.<br><br></p>

    <code>
        <span class="variable">const</span> fs = require('fs');
        <span class="variable">const</span> input = fs.readFileSync("/dev/stdin").toString().trim().split(" ");

        getNum(input[0], input[1]);

        function getNum(a, b){
            <span class="variable">let</span> result = [];
            <span class="variable">let</span> minNum = Math.min(a, b);
            <span class="variable">let</span> maxNum = Math.max(a, b);

            result[0] = gcd(minNum, maxNum)
            result[1] = lcm(minNum, maxNum);

            console.log(result[0] + ' ' + result[1]);
        }

        <span class="comment">// 최대공약수</span>
        function gcd(minNum, maxNum){
            <span class="variable">let</span> gCommon = 0;

            if((minNum % maxNum) === 0) gCommon = maxNum;
            else gCommon = gcd(maxNum, minNum % maxNum);

            return gCommon;
        }

        <span class="comment">// 최소공배수</span>
        function lcm(minNum, maxNum){
            return minNum * maxNum / gcd(minNum, maxNum);
        }
    </code>
</article>

</div>